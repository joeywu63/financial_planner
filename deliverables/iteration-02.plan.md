# FINANCIAL PLANNER FOR CANADIAN MED-SCHOOL APPLICANTS

## Iteration 2

 * Start date: Nov 1, 2019
 * End date: Nov 22, 2019

## Process

#### Roles & responsibilities


Below are the roles we will have for our team, and a short description of the responsibilities associated with each role, as well as who they will be working with.

 * Customer relations
   * Communicates with our partners on behalf of the whole team.
   * Updates our partners on the current progress.
   * Addresses questions, concerns, expectations and roadmaps for upcoming deliverables with our partners.
   * Schedules upcoming meetings with our partners.

 * Tech lead
   * Responsible for managing the technical scope of the project.
   * Mentors the rest of the team on the chosen tech stack.
   * Identifies the tasks that should be prioritized and provides estimations on the complexity of each.
   * Identifies potential problems, alternative solutions and other technical caveats that may arise in the project.

 * Quality assurance & testing lead
   * Executing tests and reviewing results after every update to the project.
   * Documenting bugs and technical issues.
   * Communicating bugs and technical issues with the rest of the team.
   * Help team members troubleshoot bugs and technical issues.

 * User experience lead
   * Identifies usability problems in user interfaces.
   * Conducts usability testing throughout the project with prototypes of varying fidelity.
   * Communicates potential usability problems to the rest of the team.
   * Identify ways to modify user interfaces to improve usability.

 * Product manager
   * Manage the product backlog by prioritizing and adding tasks.
   * Guide the development process by creating actionable user stories.
   * Ensure that completed work fulfills the user stories and acceptance criteria.

 * Scrum master
   * Identify obstacles in development and guides the team in overcoming them.
   * Ensures that milestones and deliverables are achieved in a timely manner.
   * Facilitates meetings and communication within the team.

Below is a table which outlines each team member's role(s) and responsibilities outside of coding, as well as their technical strengths and weaknesses (e.g. languages, frameworks, libraries, development methodologies, etc.)

 | Team member | Role | Responsibilities      | Strengths    | Weaknesses    |
 |-------------|------|-----------------------|--------------|---------------|
 | Julia Xu | QA | Checking code, Finding bugs | JavaScript, Python, SQL | UX, Firebase, Scrum |
 | Sandro Seryani | Scrum Master | Lead scrums, Apply Agile principles | JavaScript, React, Scrum methodologies | Deployment, Automated Testing, UX Design|
 | Lucas Gismondi | Tech Lead | Third party tool support, architecture | JavaScript, React, Firebase, Frontend Unit Tests | Deployment, UX Design |
 | Joey Wu | Customer relations | Manage partner meetings & communication | Python, C, Shell | React, Databases, Agile methodologies |
 | Tianze Xu | UX | Support UI dev. across user stories | Python, JavaScript, React, SQL | Firebase, Testing, Deployment |
 | Wendy Hua | Product Manager | Manage product backlog & development process | Javascript, React, Automated frontend testing (Puppeteer) | Firebase, Deployment|
 | Alex Eng | QA | Test code for bugs & code verification | JavaScript, Python, C | React, Firebase, UX |

#### Team Rules

**Group Communications**:

We are using the Slack app for general communications. Team members are expected to check for new messages on the app at least once per day. The Slack workspace is divided into channels for organization.

For voice or video calls, we will use Facebook or Zoom.

**Partner Communications**:

The main line of communication with the partner is through email, such as to provide updates on the project or arrange meetings. Our team representative will email the partner on behalf of the team, cc-ing the rest of the team members.

Once every 2 weeks, there will be an in-person meeting with the partner.

**Meetings**:

Team members are responsible for attending the weekly meetings. We will allow some lenience for hectic schedules, but if a team member repeatedly misses meetings, we will reach out to them, and go to the TA if they are still unresponsive. At the meetings, we will have a time where we take turns talking about our progress from the previous week. If we could not complete tasks we were responsible for (tracked through meistertask), we will look at the causes. If it is due to unexpected technical challenges, we will take it into account in workload estimates of future tasks. Then we will have take time to prioritize and assign tasks for the preceeding week.

**Conflict Resolution**:
 
 Below are several hypothetical scenarios/conflicts that may arise, and how we will resolve them.

   * There is disagreement on how to accomplish a task (technical implementation, scope etc.): In one of the weekly meetings, we would have a discussion about the strengths of each option. Then, we would take a vote. If a team member still feels strongly about the result, we would repeat the discussion process.
   * There is a task nobody wants to take on: If the task is large, we would subdivide it among the team. Otherwise, we would access the strengths and weakness of each member to decide who would have the easist time accomplishing the task. At the same time, we would make sure such "undesirable" tasks do not always go to the same person.
   * A team member is writing poor quality code: In one of the weekly meetings, we would discuss what we find lacking and offer suggestions to improve the quality of the code.
   * A team member is non-responsive/not contributing at all: If a team member is irresponsive, they will be told of the issue. If it becomes persistent, we will report to the TA.


#### Events

**Meetings**:

The team will have meetings once per week, on Fridays at 12 pm to 1 pm at Bahen, unless it has been decided that we will not be meeting that week, or that we have a partner meeting that week.

The team will have online voice call meetings as necessary, for more urgent conversations or when it is more convenient than an in-person meeting.

The purpose of team meetings is to keep everyone up-to-date on the state of the project, to assign new tasks for the upcoming week, and to review completed work.

Two members of the team will be expected to complete code reviews for each Pull Request. We will also hold quick online sync meetings when necessary.


#### Partner Meetings

**Meeting Descriptions**:

**_Meeting 1_**  
**Time and Location**  
Friday, Nov 1, 12-1pm @ David Naylor Building room 314

**Minutes**  
*Attendees:*
* Team members: Joey Wu, Lucas Gismondi, Sandro Seryani, Tianze Xu, Wendy Hua
* Project partners: Ike Okafor, Lauren Phillips

*Discussion Key Points:*  
* Demonstrated basic functionalities we implemented in the last iteration (Login, profile, admin and calculator pages).
* Discussed further functionalities we could *possibly* implement.
  * Autosaving, or a button that allows users to save their progress.
  * A way for the user to submit feedback and rate the app.
  * An option for users to enter their amount for certain expenses with estimated costs (such as plane tickets) manually.
  * An option for users to email their information to themselves.
* Determined further information partners would provide to us.
  * URLs to alternative resources
  * Short description of alternative and default resources
  * Communication timeline for MentorCity
* Partners listed further requirements/preferences.
  * Avoid too much overlap with MentorCityã€‚
  * Require that users create an account when using the app (instead of being able to use the app without an account).

*Outcomes:*
* Project partners were satisfied with current progress.

*Next Steps:*
* Project partners will provide info listed above.
* Group members will work on items listed below in "Goals and Tasks"

**_Meeting 2_**  
**Time and Location**  
Friday, Nov 22, 12-1pm @ David Naylor Building room 314

#### Artifacts   

 The team will be utilizing [MeisterTask](https://www.meistertask.com/app/dashboard) (requires invite), which is a task management platform for teams. We will use MeisterTask to assign, organize and prioritize tasks between team members, as well as keeping track of outstanding items that are not yet done.

 In MeisterTask, tasks can be created and freely moved around under four stages: Backlog, Open, In Progress and Done. We will use this
 feature to keep track of the status of each task. Each task can also be assigned a deadline, which we will use to help keep team members on schedule for deliverables. Tasks can also be moved around in each individual column and be tagged with highlight tags,
 we will use these features to prioritize tasks (more urgent tasks are placed at the top of the list)

 For our task assignment process, we will be using a volunteering system. During planning meetings, after we have refined the broad list of tasks to complete for that iteration, team members will select some task(s) to work on for that iteration based on their experience with certain technologies, their schedule and the anticipated complexity of that task (more complex tasks will need more
 team members working on them). Subteams will then be created based on the task(s) chosen by individual team members, and they will then be responsible for updating MeisterTask (moving tasks around, creating subtasks, marking them as complete) according to their progress.

#### Deployment and Github Workflow

##### Github Workflow
When a team member begins writing code for a feature, they must create a branch off master and push their changes to the new branch.
For each feature, we are currently breaking off into mini-teams to work on a singular feature. The mini-teams are responsible for merging/staying up to date/resolving conflicts within their own branch.
Once they are satisfied with their work, they will create a pull request to be reviewed by any two other members on the team.
We made the choice of having two other members review the code because it is a good middle ground between speed/efficiency and getting enough feedback.
The two members reviewing the code will be responsible for two things. 
1. Checking out the code and ensuring the feature satisfies the acceptance criteria
2. The architecture/styling of the code follows some basic standards, which are the following:
    - Any function that needs to directly access the firebase database must be in a file that lives in the 'model' directory
    - Any function, within a react component, that needs to pull data, must call the function from a repository file in the respective components directory
    - Any constant for a component must live within a constants file in the respective components directory

Note: The reason for this type of architecture is that both the backend and frontend are clearly separated. This allows for the backend to be easily swapped with another backend.
    
Once the pull request is approved, the member who issued the pull request is responsible for merging their work.
There could be conflicts with master when merging, so they will also be responsible for resolving conflicts.

We have disabled directly merging to master without a pull request for our project, so team members will be forced to go through the process described above.
The reason we chose to go this route is because this will ensure there are less bugs, higher quality code, and more team members are aware of changes.

##### Deployment
We are using firebase hosting for our project. ```firebase deploy``` is the only command we need to deploy our website.
Once the deployment process is complete from running this command, we will be able to see our changes on a live website. (The URL has currently not been decided. We will be using a generated URL from firebase for the time being.)
We chose firebase hosting and firebase in general because of its ease of use and the ability to easily switch hosting services depending on the partners needs. Firebase will save us 
a significant amount of time when having to deploy which will allow our team to focus on the product and ensure it's the best
it can be given the amount of time we have.


## Product

#### Goals and tasks

For this iteration, we aim to deliver a basic version of our product with the core functionality completed and usable
by both groups of our intended users (med school applicants and our partners at the Faculty of Medicine). Applicants will be
able to navigate through a financial planner divided into three sections, view and select from a list of costs for each section, 
and see the summation of costs as they navigate through the planner. Admins (our partners) will be able to edit the name and
cost associated with each option at will, as well as adding and deleting options.

As we aim to work on the core functionality and deliver a basic, usable version of the product, styling of the product will not be included as part of this iteration.

Below is the list of tasks we intend to complete for this iteration, ordered by importance:

- Import cost data provided by our partners into Firestore
- Be able to retrieve each cost item from our database
- Be able to display it on a webpage organized by cost type (MCAT, Application, Interview)
- Be able to display the sum of costs of selected options dynamically
- Creating an interface allowing admins to add, delete and update individual expenses
- Creating a login (authentication) system
- Creating an account registration system
- Be able to display a breakdown of costs by type, with net cost at the end

#### Artifacts

The following are artifacts we will produce in order to present our project idea.

- **Diagrams of our data model**.  We will sketch a logical data model in our initial planning meeting, so that team members
can discuss and come to a consensus with how to best structure our data. Later they will be converted to diagrams and
illustrated in our product and planning document. This will be used to explain to our partners how data is organized in our database, which is important since they will likely be updating the database after the product is complete and delivered, and knowing our data model will make working with the database much easier.